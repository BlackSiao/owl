# 并发

## 线程
平时讨论的进程只有一个执行点，但是多线程程序往往有多个执行点。线程直接可以共享地址空间，从而访问相同的数据。在多线程的进程中，每个线程都独立运行，每个线程都有独立的栈用来存放临时数据。
![](线程.png)

### 关键概念
- 临界区：访问共享资源的一段代码，资源通常是一个变量或数据结构
- 竞态条件：多个线程同时进入临界区，它们都试图更新共享的数据结构，造成结果不确定
- 不确定性：程序拥有一个或多个竞态条件，运行结果不确定
- 原子操作：这类操作只有二种状态,"执行结束"和"未开始执行"，不存在中间态。
- 为了避免这种情况，程序使用某种“互斥”的原语，保证同时只有一个线程进入临界区，从而避免竞态条件，使得结果确定

### 核心问题：不可控的调度
如果任由线程随意的执行，由于时钟中断的存在，而每个线程又拥有独立的寄存器，在访问同一数据资源的时候，其执行结果就变得不确定了

## 锁
为了解决由于多线程导致的结果不确定性，锁的概念也随着诞生。锁的原理非常容易理解：一次只能有一个线程在临时区里面访问共享资源，其他的线程此时都被隔离了。这样线程之间实现了"互斥"。

实现锁的方式有很多种，正如评价CPU的调度算法一样，我们也需要对实现锁的算法进行评估，主要评估三点：
- 1. 有效性，这个算法能否实现线程之间的互斥。
- 2. 公平性，实现这个算法能否让每个线程都有机会访问到临时区，而不出现有线程被饿死的情况。
- 3. 性能，实现该算法对整体性能的影响。

### 锁的具体实现方法

